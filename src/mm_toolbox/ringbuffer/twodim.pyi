"""
This type stub file was generated by cyright.
"""

from typing import Any

from numpy import ndarray

class RingBufferTwoDim:
    """
    A two-dimensional circular buffer for storing sub-arrays of floats.
    """
    def __init__(self, capacity: int, sub_array_len: int) -> None:
        """
        Initialize the 2D ring buffer.

        Args:
            capacity (int): Maximum number of rows the buffer can hold.
            sub_array_len (int): Number of columns (length of each sub-array).
        """
        ...

    def raw(self) -> ndarray:
        """
        Create a copy of the entire underlying 2D buffer.

        Returns:
            np.ndarray: A 2D array copy of the entire buffer space.
        """
        ...

    def unsafe_raw(self) -> ndarray:
        """
        Return a direct view of the underlying 2D array without copying.

        Returns:
            np.ndarray: A NumPy array sharing memory with the buffer.

        Warning:
            Modifying the returned array will affect this ring buffer's state.
        """
        ...

    def unwrapped(self) -> ndarray:
        """
        Return the buffer's contents in logical (unwrapped) order.

        Returns:
            np.ndarray: A 2D array in order from the oldest to the newest row.

        Tip:
            If you intend to iterate over the buffer in order for read only purposes,
            use `iter(self)` instead of `self.unwrapped()` for better performance.
        """
        ...

    def unsafe_write(self, values: ndarray, insert_idx: int = ...) -> Any:
        """
        Write values into the current right index row without moving the buffer indices.

        Args:
            values (np.ndarray): A 1D float array to write into the row.
            insert_idx (int): Column offset where values will be written.

        Warning:
            Does not check if the buffer is full. Does not advance indices.
            Intended to be paired with `unsafe_push`.
        """
        ...

    def unsafe_push(self) -> Any:
        """
        Advance indices after an `unsafe_write`, ignoring capacity checks.

        Warning:
            Overwrites oldest data if the buffer is full. Use with caution.
        """
        ...

    def append(self, values: ndarray) -> Any:
        """
        Append a new row to the buffer.

        Args:
            values (np.ndarray): A 1D float array of length `sub_array_len`.

        Raises:
            IndexError: If `values` is not 1D or its length is incorrect.
        """
        ...

    def popright(self) -> ndarray:
        """
        Remove and return the last (most recently added) row.

        Returns:
            np.ndarray: A 1D float array representing the row.

        Raises:
            IndexError: If the buffer is empty.
        """
        ...

    def popleft(self) -> ndarray:
        """
        Remove and return the first (oldest) row.

        Returns:
            np.ndarray: A 1D float array representing the row.

        Raises:
            IndexError: If the buffer is empty.
        """
        ...

    def reset(self) -> ndarray:
        """
        Reset the buffer, returning the unwrapped data prior to clearing.

        Returns:
            np.ndarray: A 2D array of the data in logical order before clearing.
        """
        ...

    def fast_reset(self) -> Any:
        """
        Quickly clear the buffer without returning old data.
        """
        ...

    def is_full(self) -> bool:
        """
        Check if the buffer is full.

        Returns:
            bool: True if size == capacity, False otherwise.
        """
        ...

    def is_empty(self) -> bool:
        """
        Check if the buffer is empty.

        Returns:
            bool: True if size == 0, False otherwise.
        """
        ...

    def __contains__(self, values):  # -> bool:
        """
        Check whether a given 1D array is present in the buffer.

        Args:
            values (np.ndarray): A 1D float array to search for.

        Returns:
            bool: True if the array is found among the rows, otherwise False.
        """
        ...

    def __iter__(self):  # -> Generator[Any, None, None]:
        """
        Iterate over rows from oldest to newest.

        Yields:
            np.ndarray: Each row as a 1D array.
        """
        ...

    def __len__(self):  # -> int:
        """
        Number of rows currently stored in the buffer.

        Returns:
            int: The size of the buffer.
        """
        ...

    def __getitem__(self, idx: int):  # -> Any:
        """
        Access a row by its logical index.

        Args:
            idx (int): The row index, 0-based from the oldest element.
                Negative indices count backward from the newest element.

        Returns:
            np.ndarray: The row as a 1D float array.

        Raises:
            IndexError: If idx is out of range.
        """
        ...
